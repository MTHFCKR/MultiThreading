package theoretical_multithread.all;

/**
 * 1.Какова цель оптимизации кода в однопоточных приложениях?
 *
 * 2.Какие механизмы синхронизации используются для управления ресурсами в однопоточных приложениях?
 *
 * 3.Какие проблемы могут возникнуть при однопоточном выполнении многозадачных приложений?
 *
 * 4.Что такое атомарные операции и как они связаны с однопоточностью?
 *
 * 5.Каким образом однопоточные системы могут быть расширены для
 * обеспечения параллелизма в задачах, которые его требуют?
 */

public class theoreticalTaskSingleThreading {
    public class SimpleThreadExample {
        private int count = 0;

        public void increment() {
            count++;
        }

        public int getCount() {
            return count;
        }

        public static void main(String[] args) {
            // Создаем экземпляр класса SimpleThreadExample

            // Запускаем два потока, каждый из которых вызывает метод increment() 1000 раз

            // Дожидаемся завершения обоих потоков

            // Выводим значение count
        }
    }












    /**
     * 1.Целью оптимизации кода в однопоточных приложениях является повышение эффективности и производительности
     * приложения. Оптимизация может включать в себя улучшение алгоритмов, уменьшение времени выполнения задач,
     * снижение потребления памяти и улучшение общей отзывчивости приложения.
     *
     * 2.В однопоточных приложениях механизмы синхронизации используются для управления доступом к общим
     * ресурсам и предотвращения конфликтов при одновременном доступе нескольких частей кода к этим ресурсам.
     * Некоторые из таких механизмов включают в себя мьютексы, семафоры, условные переменные и атомарные операции.
     *
     * 3.Проблемы, которые могут возникнуть при однопоточном выполнении многозадачных приложений, включают
     * в себя долгие времена ожидания (например, при вводе-выводе), блокировки и задержки, возникающие при ожидании
     * завершения задач, и ограничения производительности из-за одновременного выполнения нескольких задач в одном потоке.
     *
     * 4.Атомарные операции - это операции, которые выполняются целиком и неделимо. Они связаны с однопоточностью,
     * так как обеспечивают целостность данных в пределах одного потока. В однопоточных приложениях атомарные операции
     * могут использоваться для обеспечения безопасности доступа к разделяемым ресурсам.
     *
     * 5.Для расширения однопоточных систем с целью обеспечения параллелизма в задачах, которые его требуют,
     * можно использовать многопоточность. Это позволяет выполнять несколько задач параллельно, улучшая общую
     * производительность системы. Также можно использовать асинхронное программирование и асинхронные вызовы
     * для выполнения задач в фоновом режиме, не блокируя основной поток выполнения.
     *
     *
     *
     * Задача.
     * public class Example {
     *     private int count = 0;
     *
     *     public void increment() {
     *         count++;
     *     }
     *
     *     public int getCount() {
     *         return count;
     *     }
     *
     *     public static void main(String[] args) {
     *         final Example example = new Example();
     *
     *         Thread thread1 = new Thread(new Runnable() {
     *             public void run() {
     *                 for (int i = 0; i < 1000; i++) {
     *                     example.increment();
     *                 }
     *             }
     *         });
     *
     *         Thread thread2 = new Thread(new Runnable() {
     *             public void run() {
     *                 for (int i = 0; i < 1000; i++) {
     *                     example.increment();
     *                 }
     *             }
     *         });
     *
     *         thread1.start();
     *         thread2.start();
     *
     *         try {
     *             thread1.join();
     *             thread2.join();
     *         } catch (InterruptedException e) {
     *             e.printStackTrace();
     *         }
     *
     *         System.out.println("Count: " + example.getCount());
     *     }
     * }
     */
}
